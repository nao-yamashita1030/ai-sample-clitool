# パフォーマンス詳細設計

## 9.1 パフォーマンス対策詳細

### 対策1: 並列処理による高速化

- **対象処理**: リンク切れ調査処理
- **対策内容**: 複数のURLを並列で調査
- **期待効果**: 調査時間の短縮（並列リクエスト数に比例）
- **実装方法**: 
  - 並列リクエスト数を設定可能にする（デフォルト: 5）
  - セマフォパターンで並列数を制御
  - キューでURLを管理

### 対策2: URLキャッシュによる重複回避

- **対象処理**: リンク抽出・調査処理
- **対策内容**: 調査済みURLをキャッシュして重複調査を回避
- **期待効果**: 重複調査の回避による処理時間の短縮
- **実装方法**: 
  - Setを使用して調査済みURLを管理
  - メモリ上にキャッシュを保持
  - 調査終了時にキャッシュをクリア

### 対策3: データベースインデックスによる検索高速化

- **対象処理**: 調査結果の検索・フィルタリング
- **対策内容**: 適切なインデックスを設定
- **期待効果**: 検索・フィルタリングの速度向上
- **実装方法**: 
  - `scan_history_id`にインデックス
  - `url`にインデックス
  - `http_status_code`にインデックス
  - `checked_at`にインデックス

### 対策4: ページネーションによる大量データの分割表示

- **対象処理**: 調査結果一覧表示
- **対策内容**: 大量の結果をページ分割して表示
- **期待効果**: UIの応答性向上、メモリ使用量の削減
- **実装方法**: 
  - 1ページあたりの件数を制限（デフォルト: 50件）
  - ページネーションコンポーネントを実装
  - 必要なページのデータのみ取得

### 対策5: 非同期処理によるUI応答性の向上

- **対象処理**: すべてのIPC通信
- **対策内容**: すべての処理を非同期で実行
- **期待効果**: UIのフリーズを防止
- **実装方法**: 
  - Promise/async-awaitを使用
  - 長時間かかる処理は進捗を通知
  - バックグラウンドで処理を実行

### 対策6: データベース接続の最適化

- **対象処理**: データベースアクセス
- **対策内容**: 接続の再利用、トランザクションの最適化
- **期待効果**: データベースアクセスの速度向上
- **実装方法**: 
  - ORMの接続プールを使用
  - バッチ処理でトランザクションを最適化
  - 不要な接続を即座に閉じる

## 9.2 キャッシュ詳細設計

### キャッシュ戦略

- **メモリキャッシュ**: 調査済みURLをメモリ上に保持
- **キャッシュ有効期限**: 調査セッション中のみ有効
- **キャッシュ無効化**: 調査終了時に自動的にクリア

### キャッシュ対象

- **調査済みURL**: 既に調査したURLのセット
- **目的**: 重複調査の回避
- **データ構造**: `Set<string>`（URL文字列のセット）

### キャッシュ有効期限

- **有効期間**: 調査セッション中（調査開始から終了まで）
- **無効化タイミング**: 
  - 調査終了時
  - 調査停止時
  - アプリケーション終了時

### キャッシュ無効化

- **自動無効化**: 調査終了時に自動的にクリア
- **手動無効化**: 不要（調査セッションごとに自動クリア）

### キャッシュサイズ制限

- **制限**: メモリ使用量を考慮して、最大10,000件まで
- **超過時の処理**: 警告をログに記録（通常は到達しない想定）

## 9.3 データベース最適化

### クエリ最適化

- **SELECT文の最適化**: 
  - 必要なカラムのみを取得（SELECT * を避ける）
  - WHERE句で適切なインデックスを使用
  - JOINは最小限に
- **バッチ処理**: 
  - 複数の結果を一度に保存（バルクインサート）
  - トランザクションを適切に使用
- **ページネーション**: 
  - LIMIT/OFFSETを使用して必要なデータのみ取得
  - 大量データの一括取得を避ける

### インデックス最適化

- **インデックス一覧**: 
  - `scan_history.started_at`（降順、履歴一覧の並び替え用）
  - `scan_history.status`（ステータス検索用）
  - `link_check_results.scan_history_id`（調査履歴での検索用）
  - `link_check_results.url`（URL検索用）
  - `link_check_results.http_status_code`（ステータスコードでのフィルタリング用）
  - `link_check_results.checked_at`（日時での並び替え用）
- **インデックスの効果**: 
  - 検索速度の向上
  - ソート速度の向上
  - フィルタリング速度の向上

### 接続プール設定

- **接続プール**: ORM（Sequelize/TypeORM）のデフォルト設定を使用
- **最大接続数**: 10（デフォルト）
- **接続タイムアウト**: 30秒
- **アイドルタイムアウト**: 10分

## 9.4 パフォーマンス目標

### 目標値

- **1ページあたりの調査時間**: 5秒以内
- **レスポンスタイム**: ユーザー操作に対する応答は即座に（1秒以内）
- **UIの応答性**: スムーズな操作感（60fps）
- **大量データの表示**: ページネーションにより、常に1秒以内で表示

### 測定方法

- **調査時間**: 調査開始から終了までの時間を測定
- **レスポンスタイム**: IPC通信の応答時間を測定
- **UI応答性**: React DevToolsのProfilerを使用

## 9.5 パフォーマンス監視

### 監視項目

- **調査時間**: 各調査の実行時間
- **レスポンスタイム**: IPC通信の応答時間
- **メモリ使用量**: アプリケーションのメモリ使用量
- **データベースクエリ時間**: 各クエリの実行時間

### 監視方法

- **ログ**: パフォーマンス関連のログを記録
- **プロファイリング**: 必要に応じてプロファイリングツールを使用
- **メトリクス**: パフォーマンスメトリクスを記録

## 9.6 パフォーマンス改善の継続的実施

### 改善サイクル

1. **測定**: パフォーマンスを測定
2. **分析**: ボトルネックを特定
3. **改善**: 対策を実施
4. **検証**: 改善効果を検証
5. **繰り返し**: 継続的に改善

### 改善の優先順位

1. **ユーザー体験に影響する部分**: UIの応答性、調査時間
2. **大量データ処理**: データベースクエリ、ページネーション
3. **メモリ使用量**: キャッシュサイズ、メモリリークの防止

